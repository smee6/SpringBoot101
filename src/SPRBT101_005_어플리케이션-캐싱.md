# 캐싱
- Spring Boot 특징: Cache Abstraction 제공 → 캐시 저장소 교체가 쉬움
- 메모리 캐시: Caffeine, Ehcache (서버 내부)
- 분산 캐시: Redis, Memcached (서버 외부, 여러 인스턴스 공유)

## 캐싱 어노테이션
- @EnableCaching: Spring의 캐시 기능을 활성화하는 전역 설정 (CacheManager 기반)
- @Cacheable: 메서드 실행 결과를 캐시에 저장하고, 동일한 파라미터로 호출 시 캐시에서 반환
- @CacheEvict: 캐시를 무효화(삭제)하여 최신 데이터를 다시 로드하도록 함

### @EnableCaching – 캐시 기능 전역 활성화
- CacheManager를 Redis, Caffeine, Ehcache 등으로 교체 가능 → 환경별 최적화
- TTL 전략을 서비스별로 다르게 설정 가능
- @EnableCaching를 선언하면 Spring의 Cache Abstraction이 활성화
- Spring은 AOP 프록시를 생성하여, 캐시 관련 어노테이션이 붙은 메서드 호출을 가로챔
- 결과적으로, 서버 전체 범위에서 캐시 기능이 동작

```java
@Configuration //Spring에게 "이 클래스는 설정 클래스다"라고 알려주는 어노테이션
@EnableCaching // 캐시 기능 전역 활성화
public class CacheConfig {

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
        // Redis 기반 CacheManager 생성
        return RedisCacheManager.builder(redisConnectionFactory)
                .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
                        .entryTtl(Duration.ofMinutes(5)) // TTL 5분
                        .disableCachingNullValues()) // null 값 캐싱 방지
                .build();
    }
}
```

#### @Configuration 이 왜 나왔을까.
- 내부적으로 **@Component**를 포함하고 있어서, Bean 등록 대상
- @Bean 메서드를 포함할 수 있으며, 해당 메서드에서 반환하는 객체를 Spring 컨테이너에 Bean으로 등록합
- Proxy 기반으로 동작하여, @Bean 메서드가 여러 번 호출되어도 싱글톤 Bean을 보장

### @Cacheable – 메서드 결과 캐싱
- 역할: 메서드 실행 결과를 캐시에 저장하고, 동일한 파라미터로 호출 시 캐시에서 반환
- 동작 원리: 메서드 호출 전 캐시 조회 → 있으면 반환, 없으면 실행 후 캐시에 저장

```java
@Service
@RequiredArgsConstructor
public class ProductService {

    private final ProductRepository productRepository;

    @Cacheable(value = "productCache", key = "#productId") //캐시 이름과 키 지정
    public ProductDto getProductById(Long productId) {
        // 캐시에 없을 때만 실행
        return productRepository.findById(productId)
                .map(ProductDto::fromEntity)
                .orElseThrow(() -> new ProductNotFoundException(productId));
    }
}
```
- 복합 키: key = "#userId + '_' + #productId"
- 조건부 캐싱: condition = "#productId > 100"
- 동시성 제어: sync = true로 Cache Stampede 방지
- 일관성: 데이터 변경 시 반드시 @CacheEvict와 함께 사용

### @CacheEvict – 캐시 무효화
- 역할: 캐시에서 특정 키 또는 전체 데이터를 삭제
- 동작 원리: 메서드 실행 후 지정된 캐시 키를 제거 → 다음 호출 시 최신 데이터 로드

```java
@Service
@RequiredArgsConstructor
public class ProductService {

    private final ProductRepository productRepository;

    @CacheEvict(value = "productCache", key = "#productId")
    public void updateProduct(Long productId, ProductUpdateRequest request) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new ProductNotFoundException(productId));
        product.update(request);
        productRepository.save(product);
    }

    @CacheEvict(value = "productCache", allEntries = true)
    public void clearAllCache() {
        // 전체 캐시 삭제
    }
}
```
- allEntries = true: 전체 캐시 삭제 (운영 중 긴급 초기화)
- beforeInvocation = true: 메서드 실행 전 캐시 삭제 (예외 발생 시에도 캐시 삭제 보장)
