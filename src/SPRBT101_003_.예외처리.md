# 예외처리
- 원래 Spring Boot는 기본적으로 예외가 발생하면 **BasicErrorController**를 통해 /error 엔드포인트로 매핑하고, JSON 또는 HTML 에러 페이지를 반환
- 그러나 한계가 있다. (결국 사용자에게 던지는 에러 메시지가 정보가 좀 적합하지 않은 경우가 있음)

## @ControllerAdvice + @ExceptionHandler
- 실제로, 실무에서는 이 두가지를 혼합해서 응답형식과 상태코드를 정의해서 사용

## 예외처리 흐름
[Controller] → 예외 발생  
    ↓  
[DispatcherServlet]  
    ↓  
[HandlerExceptionResolver] (Spring Boot 기본 등록)  
    ↓  
@ControllerAdvice 클래스 검색  
    ↓  
@ExceptionHandler 메서드 실행  
    ↓  
ResponseEntity(JSON) 반환  

# @ControllerAdvice
- 전역 예외 처리 클래스
- Spring Boot에서 @ControllerAdvice를 붙인 클래스는 Spring Bean으로 등록
- 모든 Controller에 대해 예외를 가로채는 역할
- 일반적인 사용방법은 아래와 같음
```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAll(Exception e) {
        ErrorResponse error = new ErrorResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "서버 오류 발생",
                LocalDateTime.now()
        );
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
//➡ Exception.class를 처리하면 모든 예외를 잡을 수 있음
//또는 특정 범위만 처리할라면, 왜냐면 @ControllerAdvice는 여러 개 선언 가능 하기 때문
@ControllerAdvice(basePackages = "com.example.project.controller")
public class GlobalExceptionHandler {
    // 해당 패키지의 Controller만 처리
}
```
- 미리 에러 관련한 DTO를 만들어두면 좋음
```java
public class ErrorResponse {
    private int status;
    private String message;
    private LocalDateTime timestamp;

    public ErrorResponse(int status, String message, LocalDateTime timestamp) {
        this.status = status;
        this.message = message;
        this.timestamp = timestamp;
    }
}
```
### 동작 원리
1. Spring Boot 시작 시
- @ControllerAdvice가 붙은 클래스를 Bean으로 등록
- 내부적으로 ExceptionHandlerExceptionResolver가 이 Bean을 스캔
2. 요청 처리 중 예외 발생
- DispatcherServlet이 예외를 HandlerExceptionResolver로 전달
3. 전역 예외 처리 클래스 탐색
- 등록된 모든 @ControllerAdvice Bean을 확인
- 해당 예외 타입을 처리하는 @ExceptionHandler 메서드 찾기 (리플렉션 사용)
4. 메서드 실행 & 응답 반환
- ResponseEntity 또는 DTO를 반환
- Jackson이 JSON 변환

### 사용 예시
- Bean 등록 : @ControllerAdvice 클래스는 @Component처럼 Bean으로 등록됨
- 리플렉션 기반 매핑 : 예외 타입과 @ExceptionHandler 메서드를 런타임에 매핑
```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException e) {
        ErrorResponse error = new ErrorResponse(
                HttpStatus.NOT_FOUND.value(),
                e.getMessage(),
                LocalDateTime.now()
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException e) {
        String message = e.getBindingResult().getFieldError().getDefaultMessage();
        ErrorResponse error = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                message,
                LocalDateTime.now()
        );
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(Exception e) {
        ErrorResponse error = new ErrorResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "서버 오류 발생",
                LocalDateTime.now()
        );
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}

// 팁 : Exception.class를 처리하는 메서드는 마지막에 두기 → 세부 예외 먼저 처리
```

### ResponseStatus 통해서 에러 사용하기
```java
@ResponseStatus(HttpStatus.NOT_FOUND)
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}
//Spring Boot에서는 커스텀 예외에 @ResponseStatus를 붙이면
// @ExceptionHandler 없이도 상태 코드가 자동 적용

이렇게 되면 ➡ throw new UserNotFoundException("사용자 없음") → 404 응답 자동 반환
```
### 아 근데 ResponseStatus 하니까 생각나는건데, ResponseEntity vs @ResponseStatus
- @ResponseStatus → HTTP 상태 코드 고정, 메시지 단순
- ResponseEntity → 상태 코드, 헤더, 바디 모두 제어 가능 → 종종 실무에서는 ResponseEntity 선호

### @ExceptionHandler의 우선순위
- 가장 구체적인 예외 타입이 먼저 매칭
- 예: UserNotFoundException → RuntimeException → Exception
- Exception.class 핸들러는 마지막에 두는 게 좋음 (catch-all)

### 비동기 예외처리 할 때 자주 하는 실수
- 비동기(@Async) 예외 처리 : @Async 메서드에서 발생한 예외는 전역 핸들러로 안 감
- 이유: 비동기 실행은 다른 쓰레드에서 발생 → DispatcherServlet 흐름 밖
- 이거 중요한 거임
- 해결: CompletableFuture.exceptionally()로 처리 또는 AsyncUncaughtExceptionHandler 구현

### 범위도 중요! 인터셉터나 필터에서 발생한 예외도 여기로 안잡힘
- ControllerAdvice는 Controller 이후 단계에서만 동작
- 필터나 인터셉터에서 발생한 예외는 직접 try-catch 후 응답 작성 필요
